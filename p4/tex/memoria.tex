\documentclass[11pt]{article}

%\usepackage{palatino}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% Chivo como en las diapositivas o Fira Sans?
%\usepackage[familydefault,regular]{Chivo}
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}
\usepackage{mathastext}
\usepackage[spanish]{babel}
\setlength{\parindent}{0pt}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage[x11names, rgb, html]{xcolor}
\usepackage{graphics}
\usepackage{caption}
\usepackage{lipsum}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{geometry}
\usepackage[scaled=.85]{FiraMono}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{hyperref}

\hypersetup{
  % hidelinks = true,   % Oculta todos los enlaces.
  colorlinks = true,   % Muestra todos los enlaces, sin bordes alrededor.
  linkcolor=black,     % Color de enlaces genéricos
  citecolor={black},   % Color de enlaces de referencias
  urlcolor={blue!70!black}     % Color de enlaces de URL
}

\geometry{left=3cm,right=3cm,top=3cm,bottom=3cm,headheight=1cm,headsep=0.5cm}

%%% PGFPLOTSTABLE

\usepackage{pgfplotstable}

%%% COLORES

\definecolor{50}{HTML}{FFEBEE}
\definecolor{100}{HTML}{FFCDD2}
\definecolor{200}{HTML}{EF9A9A}
\definecolor{300}{HTML}{E57373}
\definecolor{400}{HTML}{EF5350}
\definecolor{500}{HTML}{F44336}
\definecolor{600}{HTML}{E53935}
\definecolor{700}{HTML}{D32F2F}
\definecolor{800}{HTML}{C62828}
\definecolor{900}{HTML}{B71C1C}



%% Colores de Solarized

\definecolor{sbase03}{HTML}{002B36}
\definecolor{sbase02}{HTML}{073642}
\definecolor{sbase01}{HTML}{586E75}
\definecolor{sbase00}{HTML}{657B83}
\definecolor{sbase0}{HTML}{839496}
\definecolor{sbase1}{HTML}{93A1A1}
\definecolor{sbase2}{HTML}{EEE8D5}
\definecolor{sbase3}{HTML}{FDF6E3}
\definecolor{syellow}{HTML}{B58900}
\definecolor{sorange}{HTML}{CB4B16}
\definecolor{sred}{HTML}{DC322F}
\definecolor{smagenta}{HTML}{D33682}
\definecolor{sviolet}{HTML}{6C71C4}
\definecolor{sblue}{HTML}{268BD2}
\definecolor{scyan}{HTML}{2AA198}
\definecolor{sgreen}{HTML}{859900}

%% Colores del documento

\definecolor{text}{RGB}{78,78,78}
\definecolor{accent}{RGB}{129, 26, 24}

%%% LISTINGS

\usepackage{listingsutf8}

%% Las tildes

\lstset{
  inputencoding=utf8/latin1
}

%% Colores de Solarized para listings

\lstset{
  % How/what to match
  % sensitive=true,
  % language=pseudo,
  % Border (above and below)
  frame=leftline,
  rulecolor=\color{300},
  framerule=2pt,
  % Line number
  numbers=left,
  % Extra margin on line (align with paragraph)
  xleftmargin=\parindent,
  % Put extra space under caption
  belowcaptionskip=1\baselineskip,
  % Colors
  % backgroundcolor=\color{sbase3},
  basicstyle=\footnotesize\ttfamily\color{sbase00},
  keywordstyle=\color{700},
  commentstyle=\color{300},
  stringstyle=\color{500},
  numberstyle=\color{500},
  %identifierstyle=\color{500},
  % Break long lines into multiple lines?
  breaklines=true,
  % Show a character for spaces?
  showstringspaces=false,
  tabsize=2,
  xleftmargin=0.7em,
}

\renewcommand{\lstlistingname}{Código fuente}% Listing -> Algorithm


\title{Algorítmica: práctica 4 \\ \large El recorrido del caballo\\ \vspace{0.2em}Grupo 2}
\author{Sofía Almeida Bruno \and Antonio Coín Castro \and María Victoria Granados Pozo \and Miguel Lentisco Ballesteros \and José María Martín Luque}
\date{\today}

\begin{document}
\maketitle

\newpage

\section*{Análisis del problema}

Dado un tablero de ajedrez de tamaño $N\times N$ y un caballo colocado en una posición inicial, nuestro problema consiste en pasar por todas las casillas del tablero una sola vez realizando los movimientos permitidos para el caballo. Coloquialmente, se conoce como el \textbf{problema del recorrido del caballo.}\\

Antes de comenzar con el diseño de un algoritmo que resuelva el problema, hemos consultado algunos artículos donde se discute el mismo. Por ejemplo, \textit{Cull et al.} \cite{cull} probaron el siguiente lema:\\

\textbf{Lema 1.} \textit{Todo tablero de tamaño $5\times M$ con $M\ge5$ tiene un recorrido válido del caballo.} Además, es conocido que dicho recorrido comienza en la posición más baja y más a la izquierda del tablero.\\

Además, consultando la secuencia \cite{sequence}, observamos que el problema no tiene solución si $N=2,3,4$. El caso $N=1$ se considera trivial, por lo que pondremos especial hincapié en el caso $N\ge5$.\\

Para representar nuestro problema, hemos usado una clase \verb|TableroAjedrez|. En \verb|TableroAjedrez| se encapsula la matriz que representa un tablero de ajedrez de tamaño $N\times N$, hasta un máximo fijado. Además, disponemos de un \verb|struct Posicion| que representa una casilla del tablero, para poder gestionar los (posibles) desplazamientos del caballo. Se adjunta el código fuente de la clase.\\

La solución es una secuencia de pasos que reflejan el movimiento del caballo a lo largo del tablero. A la hora de representarlo, modificaremos directamente el tablero, considerando que el contenido de la posición \verb|(i,j)| es el paso en el que el caballo se situó en la casilla que representa dicha posición.

\section*{Técnica utilizada}

Es obvio que podemos representar nuestro problema utilizando un grafo, donde los nodos serían las casillas del tablero, y las aristas conectarían casillas adyacentes. De las dos técnicas estudiadas para exploración de grafos hemos utilizado \textit{BackTracking} porque consideramos que se adapta mejor al problema que nos enfrentamos.\\

\textit{Branch\&Bound} es un procedimiento enfocado a resolver problemas de optimización, ya que se aprovecha del uso de cotas. En este caso, como simplemente queremos llegar a una solución sin minimizar ni maximizar ninguna función objetivo, no necesitamos este tipo de algoritmo.


\section*{Diseño de la solución}

Empleando un enfoque basado en la técnica \textit{BackTracking} para la resolución del problema, la idea es la siguiente. %%%TODO: completar explicación\\

En primer lugar, vamos a mostrar las componentes \textit{BackTracking} de este problema:
%%%%%%%%%%%%%%%%%%%%%%%%%%%% YA NO ESTÁ REVISADO A PARTIR DE AQUÍ %%%%%%%%%%%%%%%%%%

\begin{itemize}
	\item \textit{Lista de candidatos:} los nodos del grafo.
	\item \textit{Lista de candidatos utilizados:} los nodos ya considerados para el recubrimiento.
	\item \textit{Función solución:} que no haya ninguna arista sin considerar.
	\item \textit{Criterio de factibilidad:} que el nodo esté en la lista de candidatos (no es necesario ningún criterio adicional).
	\item \textit{Función objetivo:} recubrimiento de coste mínimo.
	\item \textit{Función de selección:} nodo en el que inciden más aristas.
\end{itemize}

Una vez que hemos visto las componentes, pasemos a ver un esqueleto o \textit{pseudocódigo} del algoritmo: \\

$N \equiv \text{ número de nodos del grafo}\\ M \equiv \text{ número de nodos del recubrimiento}\\ L \equiv \text{ matriz de adyacencia}\\ T[1,\dots,M] \equiv \text{ vector de nodos del recubrimiento}\\ V[1,\dots,N] \equiv \text{ vector de incidencias}$\\

\begin{algorithm}
\begin{algorithmic}

\Function{RecubrimientoGrafoGreedy }{$L[1,\dots,N][1,\dots,N]\ $}
    \State $T = \emptyset$ \Comment Recubrimiento
    \For{$i=1,\dots,N$}
        \State $\displaystyle V[i] \gets \sum_{j=1}^N L[i][j]$ \Comment Número de incidencias del nodo $i$
    \EndFor

    \State $p \gets \text{Nodo con más incidencias} \left( V[p] \ge V[i] \ \ \forall i \right)$ \Comment Función de selección \\

    \While{$V[p] > 0$} \Comment Función solución

        \State $T \gets T \cup \{p\}$
        \State $V[p] \gets 0$
        \For{$j=1,\dots,N$}
            \If{Están conectados $p$ y $j$ \textbf{and} $V[j] > 0$ }
                \State $V[j] \gets V[j]-1$
            \EndIf
        \EndFor
        \State $p \gets \text{Nodo con más incidencias} \left( V[p] \ge V[i] \ \ \forall i \right)$ \Comment Función de selección

    \EndWhile \\
    \State \Return $T$
\EndFunction
\end{algorithmic}
\end{algorithm}

Como se puede observar, algunas de las componentes \textit{greedy} listadas anteriormente se han omitido o modificado en la implementación, pues o bien no son necesarias, o bien es más sencillo implementarlas de otra manera.

\begin{itemize}
	\item La \textit{lista de candidatos} y la \textit{lista de candidatos utilizados} están representadas como un vector de incidencias $V$, donde si el nodo $i$ está utilizado, entonces $V[i] = 0$.
	\item El \textit{criterio de factibilidad}, como ya dijimos, no es necesario, pues todos los nodos de la \textit{lista de candidatos} son factibles. Implícitamente, estamos considerando como factibles los nodos $i$ tales que $V[i] > 0$.
	\item La \textit{función solución} es que el vector de incidencias $V$ sea distinto del vector $0$, o lo que es lo mismo, que el máximo de las componentes de $V$ no sea $0$. Esto significaría que ya se han considerado todas las aristas que inciden en cada uno de los nodos.
	\item La \textit{función de selección} consiste en seleccionar, en cada paso, la componente máxima del vector $V$, es decir, el nodo con mayor grado.
\end{itemize}

En el diseño del algoritmo nos aprovechamos del vector $V$ para identificar \textbf{cada nodo del grafo con cada posición de $V$}. Es decir, $V[i]$ representa el número de incidencias del nodo $i$.

\section*{Algoritmo BackTracking}

Veamos ahora el algoritmo implementado en el lenguaje \verb|C++|. En primer lugar, hemos separado la implementación de la \textit{función de selección}, para que se aprecie con claridad:

	%\lstinputlisting[language=C++, linerange={12-24}, caption=Función de selección]{./../src/Algoritmo.cpp}
\vspace{1em}

Ahora pasemos a la función principal. El algoritmo comienza construyendo un vector de incidencias, que contiene en cada posición $i$ el número de aristas que inciden en el nodo $i-$ésimo. Después, seleccionamos el nodo con un número mayor de incidencias, lo añadimos a la solución y eliminamos las aristas que inciden en dicho nodo. A efectos prácticos, esto consiste en poner a $0$ el número de incidencias del nodo en $V$, y en decrementar en $1$ el número de incidencias de los nodos conectados con él.\\


El algoritmo continúa repitiendo el paso anterior hasta que no quedan aristas sin considerar (notemos que no volverá a seleccionar nunca un nodo ya considerado). Cuando finalice el algoritmo, tendremos como solución un vector con los nodos utilizados en el recubrimiento, y el coste será el número de nodos del mismo.\\

%\lstinputlisting[language=C++, linerange={25-59}, caption=Algoritmo Greedy]{./../src/Algoritmo.cpp}

La solución \verb|sol| utilizada es una instacia de la clase \verb|Solucion|, que contiene un vector con los nodos y su tamaño. Esta función \verb|RecubrimientoGrafoGreedy| recibe como parámetro un objeto $p$ de la clase \verb|Problema| que encapsula la matriz de adyacencia del grafo en cuestión, donde se ven reflejadas indirectamente las incidencias de cada nodo.

%%TODO: explicar el main, y por qué diferenciamos varios casos: sol_particular, N>=5, bucle while(!tiene_sol)...

\section*{Ejemplo paso a paso}

%%% TODO: completar

\section*{Optimalidad}


%%TODO: comentar algo sobre esto en otro sitio? No merece la pena una sección. Quizás en la parte de eficiencia teórica (siempre encuentra una solución, pero en tiempos inviables).


%%%%%%%%%%%%%% DE AQUÍ EN ADELANTE ESTÁ REVISADO. FALTA RE-REVISAR %%%%%%%%%%

\section*{Problema real}

El problema del recorrido del caballo es un caso particular de un problema más general: hallar, si existe, un camino hamiltoniano \cite{wiki} en un grafo. Si además imponemos que desde la casilla donde finaliza el caballo se pueda volver a la casilla de origen mediante un movimiento válido, el problema se transforma en hallar un camino cerrado o ciclo hamiltoniano \cite{wiki}.\\

No se nos ocurre ninguna situación real de aplicación del problema del recorrido del caballo, tal y como lo hemos enunciado. Sin embargo, si consideramos el problema de hallar un camino cerrado, existe una similitud con el problema del \textit{viajante de comercio}, que consiste en hallar un ciclo hamiltoniano \textbf{minimal} para un grafo completo, no dirigido y ponderado.\\

\section*{Compilación y ejecución del proyecto}
Para compilar este proyecto simplemente hay que situarse en la carpeta \verb|p4_backtracking| y ejecutar el comando \verb|make|.\\

Una vez compilado, si estamos situados en la misma carpeta ejecutamos \verb|./bin/main| pasando como parámetro el tamaño del tablero, y opcionalmente la posición inicial del caballo. Un ejemplo del formato completo sería el siguiente: \verb|./bin/main 8 1 1|.\\

Si $N$ es el tamaño del tablero, las posiciones del caballo comienzan en $0$ y acaban en $N-1$, tanto para las filas como para las columnas.

% --------------------------------------------------------------------------------
% Bibliografía.
% --------------------------------------------------------------------------------
\begin{thebibliography}{9}

\bibitem{cull}
  Paul Cull, Jeffery De Curtins. 
  \emph{Knight's tour revisited}.
   \href{http://www.fq.math.ca/Scanned/16-3/cull.pdf}{PDF}.

\bibitem{sequence}
  Sequence
  \href{https://oeis.org/A165134}{A165134} in the OEIS.
  
\bibitem{wiki}
  \href{https://en.wikipedia.org/wiki/Hamiltonian_path_problem}{Hamiltonian path problem} on Wikipedia.

\end{thebibliography}


\end{document}
