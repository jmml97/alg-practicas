\documentclass[11pt]{article}

%\usepackage{palatino}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% Chivo como en las diapositivas o Fira Sans?
%\usepackage[familydefault,regular]{Chivo}
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}
\usepackage[spanish]{babel}
\setlength{\parindent}{0pt}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage[x11names, rgb, html]{xcolor}
\usepackage{graphics}
\usepackage{caption}
\usepackage{lipsum}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{geometry}
\usepackage[scaled=.85]{FiraMono}  

\geometry{left=3cm,right=3cm,top=3cm,bottom=3cm,headheight=1cm,headsep=0.5cm} 


%%% PGFPLOTSTABLE

\usepackage{pgfplotstable}

%%% COLORES

\definecolor{50}{HTML}{E0F7FA}
\definecolor{300}{HTML}{4DD0E1}
\definecolor{500}{HTML}{00BCD4}
\definecolor{700}{HTML}{0097A7}
\definecolor{900}{HTML}{006064}



%% Colores de Solarized

\definecolor{sbase03}{HTML}{002B36}
\definecolor{sbase02}{HTML}{073642}
\definecolor{sbase01}{HTML}{586E75}
\definecolor{sbase00}{HTML}{657B83}
\definecolor{sbase0}{HTML}{839496}
\definecolor{sbase1}{HTML}{93A1A1}
\definecolor{sbase2}{HTML}{EEE8D5}
\definecolor{sbase3}{HTML}{FDF6E3}
\definecolor{syellow}{HTML}{B58900}
\definecolor{sorange}{HTML}{CB4B16}
\definecolor{sred}{HTML}{DC322F}
\definecolor{smagenta}{HTML}{D33682}
\definecolor{sviolet}{HTML}{6C71C4}
\definecolor{sblue}{HTML}{268BD2}
\definecolor{scyan}{HTML}{2AA198}
\definecolor{sgreen}{HTML}{859900}

%% Colores del documento

\definecolor{text}{RGB}{78,78,78}
\definecolor{accent}{RGB}{129, 26, 24}

%%% LISTINGS

\usepackage{listingsutf8}

%% Las tildes

\lstset{
  inputencoding=utf8/latin1
}

%% Colores de Solarized para listings

\lstset{
  % How/what to match
  % sensitive=true,
  % language=pseudo,
  % Border (above and below)
  frame=leftline,
  rulecolor=\color{300},
  framerule=2pt,
  % Line number
  numbers=left,
  % Extra margin on line (align with paragraph)
  xleftmargin=\parindent,
  % Put extra space under caption
  belowcaptionskip=1\baselineskip,
  % Colors
  % backgroundcolor=\color{sbase3},
  basicstyle=\footnotesize\ttfamily\color{sbase00},
  keywordstyle=\color{700},
  commentstyle=\color{300},
  stringstyle=\color{500},
  numberstyle=\color{500},
  %identifierstyle=\color{500},
  % Break long lines into multiple lines?
  breaklines=true,
  % Show a character for spaces?
  showstringspaces=false,
  tabsize=2,
  xleftmargin=0.7em,
}

\renewcommand{\lstlistingname}{Código fuente}% Listing -> Algorithm


\title{Algorítmica: práctica 3 \\ \large Recubrimiento de un grafo no dirigido\\ \vspace{0.2em}Grupo 2}
\author{Sofía Almeida Bruno \and Antonio Coín Castro \and María Victoria Granados Pozo \and Miguel Lentisco Ballesteros \and José María Martín Luque}
\date{\today}

\begin{document}
\maketitle

\newpage

\section*{Introducción}

Dado un grafo no dirigido $G=(V,E)$, un conjunto $U\subseteq V$ es un recubrimiento de $G$ si cada arista de $E$ incide en, al menos, un vértice o nodo de $U$. Nuestro problema consiste en encontrar un recubrimiento minimal del grafo $G$, esto es, un recubrimiento con el menor número posible de nodos. \\

Para resolver el problema, empleamos un algoritmo \textit{greedy} (voraz). La solución que proporcionamos es el conjunto de nodos que forman el recubrimiento junto con el coste (número de nodos). \\

Para representar nuestro problema, hemos usado una clase \verb|Problema| y una clase \verb|Solucion|. En \verb|Problema| se encapsula la matriz de adyacencia del grafo (simétrica) junto con su tamaño, mientras que en \verb|Solucion| se encapsula un vector de nodos que forman el recubrimiento, junto a su tamaño.
\begin{figure}[H]
	\caption{Ejemplo de grafo. Los nodos más oscuros forman el recubrimiento}
	\centering \includegraphics{./img/grafo.pdf}
\end{figure}

\section*{Algoritmo Greedy}

En primer lugar, vamos a mostrar las componentes Greedy de este problema:

\begin{itemize}
	\item \textit{Lista de candidatos:} los nodos del grafo.
	\item \textit{Lista de candidatos utilizados:} los nodos ya considerados.
	\item \textit{Función solución:} que no haya ninguna arista sin considerar.
	\item \textit{Criterio de factibilidad:} que el nodo no esté en la lista de candidatos utilizados (no es necesario ningún criterio adicional).
	\item \textit{Función objetivo:} recubrimiento de coste mínimo.
	\item \textit{Función de selección:} nodo en el que inciden más aristas.
\end{itemize}

Veamos ahora el algoritmo:

	\lstinputlisting[language=C++, linerange={11-25}, caption=Función de selección]{./src/Algoritmo.cpp}
\vspace{1em}

El algoritmo comienza considerando contando cuántas aristas inciden en cada nodo. Así, seleccionamos en primer lugar el nodo con un número mayor de incidencias, lo añadimos a la solución y eliminamos las aristas que inciden en dicho nodo. El algoritmo continúa repitiendo el paso anterior hasta que no quedan aristas sin considerar. Cuando finalice el algoritmo tendremos como solución un vector con los nodos utilizados en el recubrimiento, el coste será el número de nodos que no será mínimo en todos los casos ya que el algoritmo no es óptimo.\\

\lstinputlisting[language=C++, linerange={25-59}, caption=Algoritmo Greedy]{./src/Algoritmo.cpp}

Esta solución S utilizada es una instacia de la clase Solucion que contiene un vector con los nodos y su tamaño.
Esta función AlgoritmoGreedyAGM toma como parámetro un p de la clase Problema que encapsula la matriz de adyacencia donde se ven reflejadas las incidencias de cada nodo.

\section*{Pseudocódigo}

\section*{Ejemplo paso a paso}
%% FIXME ARREGLAR FORMATO
Vamos a ver con un grafo concreto como funciona el algoritmo.

\begin{figure}[H]
	\caption{Ejemplo de grafo sin recubrir}
	\centering \includegraphics{./img/grafo-ejemplo-sin-recubrir.pdf}
\end{figure}

Inicialización:\\
%% FIXME centrar o poner esto de una forma adecuada
N = \verb|num_nodos| = 6

M = \verb|sol.coste| = 0

$$  L = \verb|p.matriz_adyacencia| = 
\begin{pmatrix}
	0 & 0 & 1 & 0 & 1 & 1 \\
	0 & 0 & 0 & 1 & 0 & 1 \\
	1 & 0 & 0 & 1 & 1 & 0 \\
	0 & 1 & 1 & 0 & 0 & 0 \\
	1 & 0 & 1 & 0 & 0 & 0 \\
	1 & 1 & 0 & 0 & 0 & 0
\end{pmatrix}$$

$$ VI = \verb|incidencias| = 
\begin{pmatrix}
	3 \\
	2 \\
	3 \\
	2 \\
	2 \\
	2 
\end{pmatrix}$$

p = \verb|pos_max| = 0\\

Bucle while:

\verb|incidencias[0]| = 3 > 0, entra en el bucle\\
Añadimos el nodo 0 al vector solución. T = \verb|sol.nodos| = \{0\}. 
M = \verb|sol.coste| = 1\\

\begin{figure}[H]
	\centering \includegraphics{./img/grafo-ejemplo-1.pdf}
\end{figure}

Actualizamos el vector de incidencias, eliminando a este nodo y las incidencias correspondientes. Como las aristas adyacentes al nodo 0 inciden también en los nodos 2, 4 y 5, restamos uno en dichas posiciones del vector de incidencias: \\
$$ VI = \verb|incidencias| = 
\begin{pmatrix}
	3 \\
	2 \\
	3 \\
	2 \\
	2 \\
	2 
\end{pmatrix} \implies VI = \verb|incidencias| = 
\begin{pmatrix}
	0 \\
	2 \\
	2 \\
	2 \\
	1 \\
	1 
\end{pmatrix}$$
Restablecemos el valor de p = \verb|pos_max| = 1

Como \verb|incidencias[1]| = 2 > 0, realiza otra iteración de forma similar:\\
 
 T = \verb|sol.nodos| = \{0, 1\}, M = \verb|sol.coste| = 2, las aristas que inciden en el nodo 1 lo hacen también en los nodos 3 y 5.\\
 
\begin{figure}[H]
	\centering \includegraphics{./img/grafo-ejemplo-2.pdf}
\end{figure}
 
$$ VI = \verb|incidencias| = 
\begin{pmatrix}
	0 \\
	2 \\
	2 \\
	2 \\
	1 \\
	1 
\end{pmatrix} \implies VI = \verb|incidencias| = 
\begin{pmatrix}
	0 \\
	0 \\
	2 \\
	1 \\
	1 \\
	0 
\end{pmatrix}$$

Volvemos a actualizar el valor de p = \verb|pos_max| = 2.\\
\verb|incidencias[1]| = 2 > 0, por tanto, repetimos el proceso una vez más: T  = \verb|sol.nodos| = \{0, 1, 2\}. 
M = \verb|sol.coste| = 3.

\begin{figure}[H]
	\centering \includegraphics{./img/grafo-ejemplo.pdf}
\end{figure}

Eliminando las incidencias de las aristas adyacentes a este nodo el vector de incidencias sufre el siguiente cambio:

 $$ VI = \verb|incidencias| = 
\begin{pmatrix}
	0 \\
	0 \\
	2 \\
	1 \\
	1 \\
	0  
\end{pmatrix} \implies VI = \verb|incidencias| = 
\begin{pmatrix}
	0 \\
	0 \\
	0 \\
	0 \\
	0 \\
	0 
\end{pmatrix}$$

 p = \verb|pos_max| = 0, por tanto, \verb|incidencias[1]| = 0 == 0, no entra en bucle while. Como último paso devolvemos la solución:  T  = \verb|sol.nodos| = \{0, 1, 2\}, M = \verb|sol.coste| = 3.
 
\subsection*{Eficiencia teórica}
La eficiencia del algoritmo viene dada por el bucle while. Este bucle se ejecutará hasta que todos los valores del vector de incidencias sean 0, que en el peor de los casos es el número total de nodos menos 1 (num\_nodos - 1).

En el interior de este bucle lo que nos determina la eficiencia es la función de selección de orden num\_nodos. Por tanto la eficiencia de este algoritmo es num\_nodos².


\section*{Compilar y ejecutar}
Para compilar este proyecto simplemente hay que situarse en la carpeta practica\_greedy y ejecutar el comando make.

Una vez compilado, si estamos situados en la misma carpeta ejecutamos ./bin/main pasando como parámetro cualquiera de los archivos .dat de la carpeta "datos".
%%REVIEW nombre de las carpetas y archivos


\end{document}

